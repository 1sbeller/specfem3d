!=====================================================================
!
!          S p e c f e m 3 D  B a s i n  V e r s i o n  1 . 1
!          --------------------------------------------------
!
!                 Dimitri Komatitsch and Jeroen Tromp
!    Seismological Laboratory - California Institute of Technology
!         (c) California Institute of Technology October 2002
!
!    A signed non-commercial agreement is required to use this program.
!   Please check http://www.gps.caltech.edu/research/jtromp for details.
!           Free for non-commercial academic research ONLY.
!      This program is distributed WITHOUT ANY WARRANTY whatsoever.
!      Do not redistribute this program without written permission.
!
!=====================================================================
!
! Copyright October 2002, by the California Institute of Technology.
! ALL RIGHTS RESERVED. United States Government Sponsorship Acknowledged.
!
! Any commercial use must be negotiated with the Office of Technology
! Transfer at the California Institute of Technology. This software may be
! subject to U.S. export control laws and regulations. By accepting
! this software, the user agrees to comply with all applicable U.S. export laws
! and regulations, including the International Traffic and Arms Regulations,
! 22 C.F.R. 120-130 and the Export Administration Regulations,
! 15 C.F.R. 730-744. User has the responsibility to obtain export licenses,
! or other export authority as may be required before exporting such
! information to foreign countries or providing access to foreign nationals.
! In no event shall the California Institute of Technology be liable to any
! party for direct, indirect, special, incidental or consequential damages,
! including lost profits, arising out of the use of this software and its
! documentation, even if the California Institute of Technology has been
! advised of the possibility of such damage.
!
! The California Institute of Technology specifically disclaims any
! warranties, including the implied warranties or merchantability and fitness
! for a particular purpose. The software and documentation provided hereunder
! is on an "as is" basis, and the California Institute of Technology has no
! obligations to provide maintenance, support, updates, enhancements or
! modifications.
!

  program specfem3D

  implicit none

! standard include of the MPI library
  include 'mpif.h'

  include "constants.h"
  include "precision.h"

! include values created by the mesher
  include "OUTPUT_FILES/values_from_mesher.h"

!=======================================================================!
!                                                                       !
!   specfem3D is a 3-D spectral-element solver for a basin.             !
!   It uses a mesh generated by program meshfem3D                       !
!                                                                       !
!=======================================================================!
!
! If you use this code for your own research, please send an email
! to Jeroen Tromp <jtromp@gps.caltech.edu> for information, and cite:
!
! @article{KoTr99,
! author={D. Komatitsch and J. Tromp},
! year=1999,
! title={Introduction to the spectral-element method for 3-{D} seismic wave propagation},
! journal={Geophys. J. Int.},
! volume=139,
! pages={806-822}}
!
! Evolution of the code:
! ---------------------
!
! MPI v. 1.1 Dimitri Komatitsch, Caltech, October 2002: Zhu's Moho map, scaling
!  of Vs with depth, Hauksson's regional model, attenuation, oceans, movies
! MPI v. 1.0 Dimitri Komatitsch, Caltech, May 2002: first MPI version
!                        based on global code

! memory variables and standard linear solids for attenuation
  double precision, dimension(N_SLS) :: tau_mu_dble,tau_sigma_dble,beta_dble
  double precision factor_scale_dble,one_minus_sum_beta_dble
  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION,N_SLS) :: tau_mu,tau_sigma,beta
  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION) :: factor_scale,one_minus_sum_beta

  real(kind=CUSTOM_REAL), dimension(NUM_REGIONS_ATTENUATION,N_SLS) :: tauinv,alphaval,betaval,gammaval,factor_common
  integer iattenuation
  double precision scale_factor

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_ATTENUATION,N_SLS) :: &
    R_xx,R_yy,R_xy,R_xz,R_yz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_ATTENUATION) :: &
    epsilondev_xx,epsilondev_yy,epsilondev_xy,epsilondev_xz,epsilondev_yz

  integer NPOIN2DMAX_XY

! use integer array to store topography values
  integer itopo_bathy_basin(NX_TOPO,NY_TOPO)

  integer, dimension(:), allocatable :: ibelm_xmin,ibelm_xmax, &
    ibelm_ymin,ibelm_ymax,ibelm_bottom,ibelm_top
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: &
    jacobian2D_xmin,jacobian2D_xmax,jacobian2D_ymin,jacobian2D_ymax, &
    jacobian2D_bottom,jacobian2D_top
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: normal_xmin, &
    normal_xmax,normal_ymin,normal_ymax, &
    normal_bottom,normal_top

! buffers for send and receive between faces of the slices and the chunks
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: buffer_send_faces,buffer_received_faces

! -----------------

! mesh parameters
  integer, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_AB) :: ibool

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_AB) :: &
        xix,xiy,xiz,etax,etay,etaz,gammax,gammay,gammaz,jacobian
  real(kind=CUSTOM_REAL), dimension(NGLOB_AB) :: xstore,ystore,zstore

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_AB) :: &
        kappastore,mustore

! flag for sediments
  logical not_fully_in_bedrock(NSPEC_AB)
  logical, dimension(NGLLX,NGLLY,NGLLZ,NSPEC_AB) :: flag_sediments

! Stacey
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ,NSPEC_AB) :: &
        rho_vp,rho_vs

! local to global mapping
  integer, dimension(NSPEC_AB) :: idoubling

! mass matrix
  real(kind=CUSTOM_REAL), dimension(NGLOB_AB) :: rmass

! additional mass matrix for ocean load
! ocean load mass matrix is always allocated statically even if no oceans
  real(kind=CUSTOM_REAL), dimension(NGLOB_AB) :: rmass_ocean_load
  logical, dimension(NGLOB_AB) :: updated_dof_ocean_load
  real(kind=CUSTOM_REAL) additional_term,force_normal_comp

! displacement, velocity, acceleration
  real(kind=CUSTOM_REAL), dimension(NDIM,NGLOB_AB) :: displ,veloc,accel

  real(kind=CUSTOM_REAL) xixl,xiyl,xizl,etaxl,etayl,etazl,gammaxl,gammayl,gammazl,jacobianl
  real(kind=CUSTOM_REAL) duxdxl,duxdyl,duxdzl,duydxl,duydyl,duydzl,duzdxl,duzdyl,duzdzl

  real(kind=CUSTOM_REAL) duxdxl_plus_duydyl,duxdxl_plus_duzdzl,duydyl_plus_duzdzl
  real(kind=CUSTOM_REAL) duxdyl_plus_duydxl,duzdxl_plus_duxdzl,duzdyl_plus_duydzl

  real(kind=CUSTOM_REAL) sigma_xx,sigma_yy,sigma_zz,sigma_xy,sigma_xz,sigma_yz

  real(kind=CUSTOM_REAL) hp1,hp2,hp3
  real(kind=CUSTOM_REAL) fac1,fac2,fac3
  real(kind=CUSTOM_REAL) lambdal,kappal,mul,lambdalplus2mul

  real(kind=CUSTOM_REAL) tempx1l,tempx2l,tempx3l
  real(kind=CUSTOM_REAL) tempy1l,tempy2l,tempy3l
  real(kind=CUSTOM_REAL) tempz1l,tempz2l,tempz3l

  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ) :: &
    tempx1,tempx2,tempx3,tempy1,tempy2,tempy3,tempz1,tempz2,tempz3

! for attenuation
  real(kind=CUSTOM_REAL) R_xx_val,R_yy_val
  real(kind=CUSTOM_REAL) factor_loc,alphaval_loc,betaval_loc,gammaval_loc,Sn,Snp1
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY,NGLLZ) :: epsilondev_xx_loc, &
    epsilondev_yy_loc, epsilondev_xy_loc, epsilondev_xz_loc, epsilondev_yz_loc
  real(kind=CUSTOM_REAL) epsilon_trace_over_3

  integer l
  integer i_SLS
  real(kind=CUSTOM_REAL) one_minus_sum_beta_use,minus_sum_beta
  integer iselected

! --------

! parameters for the source
  integer it,isource
  integer, dimension(:), allocatable :: islice_selected_source,ispec_selected_source
  integer yr,jda,ho,mi
  real(kind=CUSTOM_REAL) stf_used
  real(kind=CUSTOM_REAL), dimension(:,:,:,:), allocatable :: sourcearray
  real(kind=CUSTOM_REAL), dimension(:,:,:,:,:), allocatable :: sourcearrays
  double precision sec,stf
  double precision, dimension(:), allocatable :: Mxx,Myy,Mzz,Mxy,Mxz,Myz
  double precision, dimension(:), allocatable :: xi_source,eta_source,gamma_source
  double precision, dimension(:), allocatable :: t_cmt,hdur
  double precision, dimension(:), allocatable :: utm_x_source,utm_y_source
  double precision, external :: comp_source_time_function


! time scheme
  real(kind=CUSTOM_REAL) deltat,deltatover2,deltatsqover2

! receiver information
  integer nrec,nrec_local,nrec_tot_found
  integer irec_local
  integer, allocatable, dimension(:) :: islice_selected_rec,ispec_selected_rec,number_receiver_global
  double precision, allocatable, dimension(:) :: xi_receiver,eta_receiver
  double precision hlagrange

! timing information for the stations
  double precision, allocatable, dimension(:,:,:) :: nu
  character(len=8), allocatable, dimension(:) :: station_name,network_name

! seismograms
  double precision uxd,uyd,uzd
  real(kind=CUSTOM_REAL), dimension(:,:,:), allocatable :: seismograms

  integer i,j,k,ispec,irec,iglob

! Gauss-Lobatto-Legendre points of integration and weights
  double precision, dimension(NGLLX) :: xigll,wxgll
  double precision, dimension(NGLLY) :: yigll,wygll
  double precision, dimension(NGLLZ) :: zigll,wzgll

! array with derivatives of Lagrange polynomials and precalculated products
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLX) :: hprime_xx,hprimewgll_xx
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLY) :: hprime_yy,hprimewgll_yy
  real(kind=CUSTOM_REAL), dimension(NGLLZ,NGLLZ) :: hprime_zz,hprimewgll_zz
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLY) :: wgllwgll_xy
  real(kind=CUSTOM_REAL), dimension(NGLLX,NGLLZ) :: wgllwgll_xz
  real(kind=CUSTOM_REAL), dimension(NGLLY,NGLLZ) :: wgllwgll_yz

! Lagrange interpolators at receivers
  double precision, dimension(:), allocatable :: hxir,hetar,hpxir,hpetar
  double precision, dimension(:,:), allocatable :: hxir_store,hetar_store

! 2-D addressing and buffers for summation between slices
  integer, dimension(:), allocatable :: iboolleft_xi, &
    iboolright_xi,iboolleft_eta,iboolright_eta

! for addressing of the slices
  integer, dimension(:,:), allocatable :: addressing
  integer, dimension(:), allocatable :: iproc_xi_slice,iproc_eta_slice

! proc numbers for MPI
  integer myrank,sizeprocs,ier

  integer npoin2D_xi,npoin2D_eta

  integer iproc_xi,iproc_eta,iproc,iproc_read

! maximum of the norm of the displacement
  real(kind=CUSTOM_REAL) Usolidnorm,Usolidnorm_all

! timer MPI
  integer ihours,iminutes,iseconds,int_tCPU
  double precision time_start,tCPU

! parameters read from parameter file
  integer NER_SEDIM,NER_BASEMENT_SEDIM,NER_16_BASEMENT, &
             NER_MOHO_16,NER_BOTTOM_MOHO,NEX_ETA,NEX_XI, &
             NPROC_ETA,NPROC_XI,NSEIS,NSTEP,UTM_PROJECTION_ZONE
  integer NSOURCES

  double precision UTM_X_MIN,UTM_X_MAX,UTM_Y_MIN,UTM_Y_MAX,Z_DEPTH_BLOCK
  double precision DT,LAT_MIN,LAT_MAX,LONG_MIN,LONG_MAX
  double precision THICKNESS_TAPER_BLOCKS,VP_MIN_GOCAD,VP_VS_RATIO_GOCAD_TOP,VP_VS_RATIO_GOCAD_BOTTOM

  logical HARVARD_3D_GOCAD_MODEL,TOPOGRAPHY,ATTENUATION, &
          OCEANS,IMPOSE_MINIMUM_VP_GOCAD,HAUKSSON_REGIONAL_MODEL, &
          BASEMENT_MAP,MOHO_MAP_LUPEI,STACEY_ABS_CONDITIONS

  logical SAVE_AVS_DX_MOVIE,SAVE_DISPLACEMENT,USE_HIGHRES_FOR_MOVIES
  integer NMOVIE
  double precision HDUR_MIN_MOVIES

  character(len=150) LOCAL_PATH,prname

! parameters deduced from parameters read from file
  integer NPROC,NEX_PER_PROC_XI,NEX_PER_PROC_ETA
  integer NER

  integer NSPEC2D_A_XI,NSPEC2D_B_XI, &
               NSPEC2D_A_ETA,NSPEC2D_B_ETA, &
               NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX, &
               NSPEC2D_BOTTOM,NSPEC2D_TOP, &
               NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX

! names of the data files for all the processors in MPI
  character(len=150) outputname

! Stacey conditions put back
  integer nspec2D_xmin,nspec2D_xmax,nspec2D_ymin,nspec2D_ymax,ispec2D
  integer, dimension(:,:), allocatable :: nimin,nimax,njmin,njmax,nkmin_xi,nkmin_eta
  real(kind=CUSTOM_REAL) vx,vy,vz,nx,ny,nz,tx,ty,tz,vn,weight

! to save movie frames
  integer ipoin
  real(kind=CUSTOM_REAL), dimension(:), allocatable :: &
      store_val_x,store_val_y,store_val_z, &
      store_val_ux,store_val_uy,store_val_uz, &
      store_val_norm_displ,store_val_norm_veloc,store_val_norm_accel
  real(kind=CUSTOM_REAL), dimension(:,:), allocatable :: &
      store_val_x_all,store_val_y_all,store_val_z_all, &
      store_val_ux_all,store_val_uy_all,store_val_uz_all

! ************** PROGRAM STARTS HERE **************

! initialize the MPI communicator and start the NPROC MPI processes.
! sizeprocs returns number of processes started
! (should be equal to NPROC)
! myrank is the rank of each process, between 0 and sizeprocs-1.
! as usual in MPI, process 0 is in charge of coordinating everything
! and also takes care of the main output
  call MPI_INIT(ier)
  call MPI_COMM_SIZE(MPI_COMM_WORLD,sizeprocs,ier)
  call MPI_COMM_RANK(MPI_COMM_WORLD,myrank,ier)

! read the parameter file
  call read_parameter_file(LAT_MIN,LAT_MAX,LONG_MIN,LONG_MAX, &
        UTM_X_MIN,UTM_X_MAX,UTM_Y_MIN,UTM_Y_MAX,Z_DEPTH_BLOCK, &
        NER_SEDIM,NER_BASEMENT_SEDIM,NER_16_BASEMENT,NER_MOHO_16,NER_BOTTOM_MOHO, &
        NEX_ETA,NEX_XI,NPROC_ETA,NPROC_XI,NSEIS,NSTEP,UTM_PROJECTION_ZONE,DT, &
        ATTENUATION,HARVARD_3D_GOCAD_MODEL,TOPOGRAPHY,LOCAL_PATH,NSOURCES, &
        THICKNESS_TAPER_BLOCKS,VP_MIN_GOCAD,VP_VS_RATIO_GOCAD_TOP,VP_VS_RATIO_GOCAD_BOTTOM, &
        OCEANS,IMPOSE_MINIMUM_VP_GOCAD,HAUKSSON_REGIONAL_MODEL, &
        BASEMENT_MAP,MOHO_MAP_LUPEI,STACEY_ABS_CONDITIONS, &
        SAVE_AVS_DX_MOVIE,SAVE_DISPLACEMENT,NMOVIE,HDUR_MIN_MOVIES,USE_HIGHRES_FOR_MOVIES)

! compute other parameters based upon values read
  call compute_parameters(NER,NEX_XI,NEX_ETA,NPROC_XI,NPROC_ETA, &
      NPROC,NEX_PER_PROC_XI,NEX_PER_PROC_ETA, &
      NER_BOTTOM_MOHO,NER_MOHO_16,NER_16_BASEMENT,NER_BASEMENT_SEDIM,NER_SEDIM, &
      NSPEC_AB,NSPEC2D_A_XI,NSPEC2D_B_XI, &
      NSPEC2D_A_ETA,NSPEC2D_B_ETA, &
      NSPEC2DMAX_XMIN_XMAX,NSPEC2DMAX_YMIN_YMAX,NSPEC2D_BOTTOM,NSPEC2D_TOP, &
      NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX,NGLOB_AB)

! open main output file, only written to by process 0
  if(myrank == 0 .and. IMAIN /= ISTANDARD_OUTPUT) &
    open(unit=IMAIN,file='OUTPUT_FILES/output_solver.txt',status='unknown')

  if(myrank == 0) then

  write(IMAIN,*)
  write(IMAIN,*) '**********************************************'
  write(IMAIN,*) '**** Specfem 3-D Solver - MPI version f90 ****'
  write(IMAIN,*) '**********************************************'
  write(IMAIN,*)
  write(IMAIN,*)

  if(FIX_UNDERFLOW_PROBLEM) write(IMAIN,*) 'Fixing slow underflow trapping problem using small initial field'

  write(IMAIN,*)
  write(IMAIN,*) 'There are ',sizeprocs,' MPI processes'
  write(IMAIN,*) 'Processes are numbered from 0 to ',sizeprocs-1
  write(IMAIN,*)

  write(IMAIN,*) 'There are ',NEX_XI,' elements along xi'
  write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta'
  write(IMAIN,*)
  write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi'
  write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta'
  write(IMAIN,*) 'There is a total of ',NPROC,' slices'

  write(IMAIN,*)
  write(IMAIN,*) ' NDIM = ',NDIM
  write(IMAIN,*)
  write(IMAIN,*) ' NGLLX = ',NGLLX
  write(IMAIN,*) ' NGLLY = ',NGLLY
  write(IMAIN,*) ' NGLLZ = ',NGLLZ
  write(IMAIN,*)

! write information about precision used for floating-point operations
  if(CUSTOM_REAL == SIZE_REAL) then
    write(IMAIN,*) 'using single precision for the calculations'
  else
    write(IMAIN,*) 'using double precision for the calculations'
  endif
  write(IMAIN,*)
  write(IMAIN,*) 'smallest and largest possible floating-point numbers are: ',tiny(1._CUSTOM_REAL),huge(1._CUSTOM_REAL)
  write(IMAIN,*)

  endif

! check that the code is running with the requested nb of processes
  if(sizeprocs /= NPROC) call exit_MPI(myrank,'wrong number of MPI processes')

! check that we have at least one source
  if(NSOURCES < 1) call exit_MPI(myrank,'need at least one source')

! dynamic allocation of arrays

! 2-D addressing and buffers for summation between slices, and point codes
! use number of elements found in the mantle since it is the largest region

! crust and mantle
  allocate(iboolleft_xi(NPOIN2DMAX_XMIN_XMAX))
  allocate(iboolright_xi(NPOIN2DMAX_XMIN_XMAX))
  allocate(iboolleft_eta(NPOIN2DMAX_YMIN_YMAX))
  allocate(iboolright_eta(NPOIN2DMAX_YMIN_YMAX))

! for addressing of the slices
  allocate(addressing(0:NPROC_XI-1,0:NPROC_ETA-1))
  allocate(iproc_xi_slice(0:NPROC-1))
  allocate(iproc_eta_slice(0:NPROC-1))

! open file with global slice number addressing
  open(unit=IIN,file='OUTPUT_FILES/addressing.txt',status='old')
  do iproc = 0,NPROC-1
    read(IIN,*) iproc_read,iproc_xi,iproc_eta
    if(iproc_read /= iproc) call exit_MPI(myrank,'incorrect slice number read')
    addressing(iproc_xi,iproc_eta) = iproc
    iproc_xi_slice(iproc) = iproc_xi
    iproc_eta_slice(iproc) = iproc_eta
  enddo
  close(IIN)

! determine local slice coordinates using addressing
  iproc_xi = iproc_xi_slice(myrank)
  iproc_eta = iproc_eta_slice(myrank)

! define maximum size for message buffers
  NPOIN2DMAX_XY = max(NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX)

  allocate(buffer_send_faces(NDIM,NPOIN2DMAX_XY))
  allocate(buffer_received_faces(NDIM,NPOIN2DMAX_XY))

! start reading the databases

! read arrays created by the mesher

  call read_arrays_solver(myrank,xstore,ystore,zstore, &
            xix,xiy,xiz,etax,etay,etaz,gammax,gammay,gammaz,jacobian, &
            flag_sediments,not_fully_in_bedrock,rho_vp,rho_vs, &
            kappastore,mustore,ibool,idoubling,rmass,rmass_ocean_load,LOCAL_PATH,OCEANS)

! check that the number of points in this slice is correct

  if(minval(ibool(:,:,:,:)) /= 1 .or. maxval(ibool(:,:,:,:)) /= NGLOB_AB) &
      call exit_MPI(myrank,'incorrect global numbering: iboolmax does not equal nglob in crust and mantle')

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read basin topography and bathymetry file
  if(TOPOGRAPHY .or. OCEANS) then
    call read_basin_topo_bathy_file(itopo_bathy_basin)
    if(myrank == 0) then
      write(IMAIN,*)
      write(IMAIN,*) 'regional topography file read ranges in m from ', &
        minval(itopo_bathy_basin),' to ',maxval(itopo_bathy_basin)
      write(IMAIN,*)
    endif
  endif

! allocate arrays for source
  allocate(sourcearray(NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(sourcearrays(NSOURCES,NDIM,NGLLX,NGLLY,NGLLZ))
  allocate(islice_selected_source(NSOURCES))
  allocate(ispec_selected_source(NSOURCES))
  allocate(Mxx(NSOURCES))
  allocate(Myy(NSOURCES))
  allocate(Mzz(NSOURCES))
  allocate(Mxy(NSOURCES))
  allocate(Mxz(NSOURCES))
  allocate(Myz(NSOURCES))
  allocate(xi_source(NSOURCES))
  allocate(eta_source(NSOURCES))
  allocate(gamma_source(NSOURCES))
  allocate(t_cmt(NSOURCES))
  allocate(hdur(NSOURCES))
  allocate(utm_x_source(NSOURCES))
  allocate(utm_y_source(NSOURCES))

! locate sources in the mesh
  call locate_source(ibool,NSOURCES,myrank,NSPEC_AB,NGLOB_AB, &
          xstore,ystore,zstore,xigll,yigll,zigll,NPROC, &
          sec,t_cmt,yr,jda,ho,mi,utm_x_source,utm_y_source, &
          NSTEP,DT,hdur,Mxx,Myy,Mzz,Mxy,Mxz,Myz, &
          islice_selected_source,ispec_selected_source, &
          xi_source,eta_source,gamma_source, &
          LAT_MIN,LAT_MAX,LONG_MIN,LONG_MAX,Z_DEPTH_BLOCK, &
          TOPOGRAPHY,itopo_bathy_basin,UTM_PROJECTION_ZONE,mustore)

  if(t_cmt(1) /= 0.) call exit_MPI(myrank,'t_cmt for the first source should be zero')
  do isource = 2,NSOURCES
    if(t_cmt(isource) < 0.) call exit_MPI(myrank,'t_cmt should not be less than zero')
  enddo

! for the movies, we do not use a Heaviside source
  if(SAVE_AVS_DX_MOVIE .and. minval(hdur) < HDUR_MIN_MOVIES) &
    call exit_MPI(myrank,'hdur too small for movie creation')

  open(unit=IIN,file='DATA/STATIONS_FILTERED',status='old')
  read(IIN,*) nrec
  close(IIN)

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of receivers = ',nrec
    write(IMAIN,*)
  endif

  if(nrec < 1) call exit_MPI(myrank,'need at least one receiver')

! allocate memory for receiver arrays
  allocate(islice_selected_rec(nrec))
  allocate(ispec_selected_rec(nrec))
  allocate(xi_receiver(nrec))
  allocate(eta_receiver(nrec))
  allocate(station_name(nrec))
  allocate(network_name(nrec))
  allocate(nu(NDIM,NDIM,nrec))

! locate receivers in the crust in the mesh
  call locate_receivers(ibool,myrank,NSPEC_AB,NGLOB_AB,idoubling, &
            xstore,ystore,zstore,xigll,yigll, &
            nrec,islice_selected_rec,ispec_selected_rec, &
            xi_receiver,eta_receiver,station_name,network_name,nu, &
            NPROC,utm_x_source(1),utm_y_source(1), &
            TOPOGRAPHY,itopo_bathy_basin,UTM_PROJECTION_ZONE)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

! read 2-D addressing for summation between slices with MPI

  call read_arrays_buffers_solver(myrank,iboolleft_xi, &
     iboolright_xi,iboolleft_eta,iboolright_eta, &
     npoin2D_xi,npoin2D_eta, &
     NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX,LOCAL_PATH)

! $$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

  if(myrank == 0) then
    write(IMAIN,*) '******************************************'
    write(IMAIN,*) 'There are ',NEX_XI,' elements along xi'
    write(IMAIN,*) 'There are ',NEX_ETA,' elements along eta'
    write(IMAIN,*)
    write(IMAIN,*) 'There are ',NPROC_XI,' slices along xi'
    write(IMAIN,*) 'There are ',NPROC_ETA,' slices along eta'
    write(IMAIN,*) 'There is a total of ',NPROC,' slices'
    write(IMAIN,*) '******************************************'
    write(IMAIN,*)
  endif

! set up GLL points, weights and derivation matrices
  call define_derivation_matrices(xigll,yigll,zigll,wxgll,wygll,wzgll, &
         hprime_xx,hprime_yy,hprime_zz, &
         hprimewgll_xx,hprimewgll_yy,hprimewgll_zz, &
         wgllwgll_xy,wgllwgll_xz,wgllwgll_yz)

! allocate 1-D Lagrange interpolators and derivatives
  allocate(hxir(NGLLX))
  allocate(hpxir(NGLLX))
  allocate(hetar(NGLLY))
  allocate(hpetar(NGLLY))

! create name of database
  call create_name_database(prname,myrank,LOCAL_PATH)

! dynamic allocation of arrays

! boundary parameters locator
  allocate(ibelm_xmin(NSPEC2DMAX_XMIN_XMAX))
  allocate(ibelm_xmax(NSPEC2DMAX_XMIN_XMAX))
  allocate(ibelm_ymin(NSPEC2DMAX_YMIN_YMAX))
  allocate(ibelm_ymax(NSPEC2DMAX_YMIN_YMAX))
  allocate(ibelm_bottom(NSPEC2D_BOTTOM))
  allocate(ibelm_top(NSPEC2D_TOP))

  allocate(jacobian2D_xmin(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX))
  allocate(jacobian2D_xmax(NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX))
  allocate(jacobian2D_ymin(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX))
  allocate(jacobian2D_ymax(NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX))
  allocate(jacobian2D_bottom(NGLLX,NGLLY,NSPEC2D_BOTTOM))
  allocate(jacobian2D_top(NGLLX,NGLLY,NSPEC2D_TOP))

! Stacey put back
  allocate(nimin(2,NSPEC2DMAX_YMIN_YMAX))
  allocate(nimax(2,NSPEC2DMAX_YMIN_YMAX))
  allocate(njmin(2,NSPEC2DMAX_XMIN_XMAX))
  allocate(njmax(2,NSPEC2DMAX_XMIN_XMAX))
  allocate(nkmin_xi(2,NSPEC2DMAX_XMIN_XMAX))
  allocate(nkmin_eta(2,NSPEC2DMAX_YMIN_YMAX))

! normals
  allocate(normal_xmin(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX))
  allocate(normal_xmax(NDIM,NGLLY,NGLLZ,NSPEC2DMAX_XMIN_XMAX))
  allocate(normal_ymin(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX))
  allocate(normal_ymax(NDIM,NGLLX,NGLLZ,NSPEC2DMAX_YMIN_YMAX))
  allocate(normal_bottom(NDIM,NGLLX,NGLLY,NSPEC2D_BOTTOM))
  allocate(normal_top(NDIM,NGLLX,NGLLY,NSPEC2D_TOP))

! boundary parameters
  open(unit=27,file=prname(1:len_trim(prname))//'ibelm.bin',status='old',form='unformatted')
  read(27) ibelm_xmin
  read(27) ibelm_xmax
  read(27) ibelm_ymin
  read(27) ibelm_ymax
  read(27) ibelm_bottom
  read(27) ibelm_top
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'normal.bin',status='old',form='unformatted')
  read(27) normal_xmin
  read(27) normal_xmax
  read(27) normal_ymin
  read(27) normal_ymax
  read(27) normal_bottom
  read(27) normal_top
  close(27)

! Stacey put back
  open(unit=27,file=prname(1:len_trim(prname))//'nspec2D.bin',status='unknown',form='unformatted')
  read(27) nspec2D_xmin
  read(27) nspec2D_xmax
  read(27) nspec2D_ymin
  read(27) nspec2D_ymax
  close(27)

  open(unit=27,file=prname(1:len_trim(prname))//'jacobian2D.bin',status='old',form='unformatted')
  read(27) jacobian2D_xmin
  read(27) jacobian2D_xmax
  read(27) jacobian2D_ymin
  read(27) jacobian2D_ymax
  read(27) jacobian2D_bottom
  read(27) jacobian2D_top
  close(27)

! Stacey put back
! read arrays for Stacey conditions

  if(STACEY_ABS_CONDITIONS) then
      open(unit=27,file=prname(1:len_trim(prname))//'nimin.bin',status='unknown',form='unformatted')
      read(27) nimin
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nimax.bin',status='unknown',form='unformatted')
      read(27) nimax
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmin.bin',status='unknown',form='unformatted')
      read(27) njmin
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'njmax.bin',status='unknown',form='unformatted')
      read(27) njmax
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_xi.bin',status='unknown',form='unformatted')
      read(27) nkmin_xi
      close(27)

      open(unit=27,file=prname(1:len_trim(prname))//'nkmin_eta.bin',status='unknown',form='unformatted')
      read(27) nkmin_eta
      close(27)
  endif

  do isource = 1,NSOURCES

!   check that the source slice number is okay
    if(islice_selected_source(isource) < 0 .or. islice_selected_source(isource) > NPROC-1) &
      call exit_MPI(myrank,'something is wrong with the source slice number')

!   compute source arrays in source slice
    if(myrank == islice_selected_source(isource)) then
      call compute_arrays_source(ispec_selected_source(isource), &
             xi_source(isource),eta_source(isource),gamma_source(isource),sourcearray, &
             Mxx(isource),Myy(isource),Mzz(isource),Mxy(isource),Mxz(isource),Myz(isource), &
             xix,xiy,xiz,etax,etay,etaz,gammax,gammay,gammaz, &
             xigll,yigll,zigll,NSPEC_AB)
      sourcearrays(isource,:,:,:,:) = sourcearray(:,:,:,:)
    endif

  enddo

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Total number of samples for seismograms = ',NSTEP
    write(IMAIN,*)
  endif

!--- select local receivers

! count number of receivers located in this slice
  nrec_local = 0

  do irec = 1,nrec

! check that the receiver slice number is okay
  if(islice_selected_rec(irec) < 0 .or. islice_selected_rec(irec) > NPROC-1) &
    call exit_MPI(myrank,'something is wrong with the receiver slice number')

! write info about that receiver
  if(myrank == islice_selected_rec(irec)) then

    nrec_local = nrec_local + 1

  endif

  enddo

! allocate seismogram array
  allocate(seismograms(NDIM,nrec_local,NSTEP))

! allocate Lagrange interpolators for receivers
  allocate(hxir_store(nrec_local,NGLLX))
  allocate(hetar_store(nrec_local,NGLLY))

! define local to global receiver numbering mapping
  allocate(number_receiver_global(nrec_local))
  irec_local = 0
  do irec = 1,nrec
    if(myrank == islice_selected_rec(irec)) then
      irec_local = irec_local + 1
      number_receiver_global(irec_local) = irec
    endif
  enddo

! define and store Lagrange interpolators at all the receivers
  do irec_local = 1,nrec_local
    irec = number_receiver_global(irec_local)
    call lagrange_any(xi_receiver(irec),NGLLX,xigll,hxir,hpxir)
    call lagrange_any(eta_receiver(irec),NGLLY,yigll,hetar,hpetar)
    hxir_store(irec_local,:) = hxir(:)
    hetar_store(irec_local,:) = hetar(:)
  enddo

! check that the sum of the number of receivers in each slice is nrec
  call MPI_REDUCE(nrec_local,nrec_tot_found,1,MPI_INTEGER,MPI_SUM,0, &
                          MPI_COMM_WORLD,ier)
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'found a total of ',nrec_tot_found,' receivers in all the slices'
    if(nrec_tot_found /= nrec) then
      call exit_MPI(myrank,'problem when dispatching the receivers')
    else
      write(IMAIN,*) 'this total is okay'
    endif
  endif

! initialize seismograms
  seismograms(:,:,:) = 0._CUSTOM_REAL

  if(myrank == 0) then

  if(NSOURCES > 1) write(IMAIN,*) 'Using ',NSOURCES,' point sources'

  write(IMAIN,*)
  if(TOPOGRAPHY) then
    write(IMAIN,*) 'incorporating surface topography'
  else
    write(IMAIN,*) 'no surface topography'
  endif

  write(IMAIN,*)
  if(HARVARD_3D_GOCAD_MODEL) then
    write(IMAIN,*) 'incorporating 3-D lateral variations'
  else
    write(IMAIN,*) 'no 3-D lateral variations'
  endif

  write(IMAIN,*)
  if(ATTENUATION) then
    write(IMAIN,*) 'incorporating attenuation using ',N_SLS,' standard linear solids'
  else
    write(IMAIN,*) 'no attenuation'
  endif

  write(IMAIN,*)
  if(OCEANS) then
    write(IMAIN,*) 'incorporating the oceans using equivalent load'
  else
    write(IMAIN,*) 'no oceans'
  endif

  endif

! synchronize all the processes before assembling the mass matrix
! to make sure all the nodes have finished to read their databases
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! the mass matrix needs to be assembled with MPI here once and for all
  call assemble_MPI_scalar(rmass,iproc_xi,iproc_eta,addressing, &
            iboolleft_xi,iboolright_xi,iboolleft_eta,iboolright_eta, &
            buffer_send_faces,buffer_received_faces,npoin2D_xi,npoin2D_eta, &
            NPROC_XI,NPROC_ETA,NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX,NPOIN2DMAX_XY)

  if(myrank == 0) write(IMAIN,*) 'end assembling MPI mass matrix'

! check that mass matrix is positive
  if(minval(rmass(:)) <= 0.) call exit_MPI(myrank,'negative mass matrix term')
  if(OCEANS .and. minval(rmass_ocean_load(:)) <= 0.) &
       call exit_MPI(myrank,'negative ocean load mass matrix term')

! for efficiency, invert final mass matrix once and for all in each slice
  if(OCEANS) rmass_ocean_load(:) = 1. / rmass_ocean_load(:)
  rmass(:) = 1.0 / rmass(:)

! if attenuation is on, shift PREM to right frequency
! rescale mu in PREM to average frequency for attenuation

  if(ATTENUATION) then

! get and store PREM attenuation model
    do iattenuation = 1,NUM_REGIONS_ATTENUATION

      call get_attenuation_model(myrank,iattenuation,tau_mu_dble, &
        tau_sigma_dble,beta_dble,one_minus_sum_beta_dble,factor_scale_dble)

! distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        tau_mu(iattenuation,:) = sngl(tau_mu_dble(:))
        tau_sigma(iattenuation,:) = sngl(tau_sigma_dble(:))
        beta(iattenuation,:) = sngl(beta_dble(:))
        factor_scale(iattenuation) = sngl(factor_scale_dble)
        one_minus_sum_beta(iattenuation) = sngl(one_minus_sum_beta_dble)
      else
        tau_mu(iattenuation,:) = tau_mu_dble(:)
        tau_sigma(iattenuation,:) = tau_sigma_dble(:)
        beta(iattenuation,:) = beta_dble(:)
        factor_scale(iattenuation) = factor_scale_dble
        one_minus_sum_beta(iattenuation) = one_minus_sum_beta_dble
      endif
    enddo

! rescale shear modulus according to attenuation model

    do ispec = 1,NSPEC_AB
    if(not_fully_in_bedrock(ispec)) then
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX

! distinguish attenuation factors
   if(flag_sediments(i,j,k,ispec)) then
     scale_factor = factor_scale(IATTENUATION_SEDIMENTS)
   else
     scale_factor = factor_scale(IATTENUATION_BEDROCK)
   endif

      mustore(i,j,k,ispec) = mustore(i,j,k,ispec) * scale_factor

          enddo
        enddo
      enddo
    endif
    enddo

  endif

! initialize arrays to zero
  displ(:,:) = 0._CUSTOM_REAL
  veloc(:,:) = 0._CUSTOM_REAL
  accel(:,:) = 0._CUSTOM_REAL

! put negligible initial value to avoid very slow underflow trapping
  if(FIX_UNDERFLOW_PROBLEM) displ(:,:) = VERYSMALLVAL

! synchronize all processes to make sure everybody is ready to start time loop
  call MPI_BARRIER(MPI_COMM_WORLD,ier)
  if(myrank == 0) write(IMAIN,*) 'All processes are synchronized before time loop'

! allocate files to save movies and shaking map
  if(SAVE_AVS_DX_MOVIE) then

! save all points for high resolution, or only four corners for low resolution
    if(USE_HIGHRES_FOR_MOVIES) then
      allocate(store_val_x(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_y(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_z(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_ux(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_uy(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_uz(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_norm_displ(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_norm_veloc(NGLLSQUARE*NSPEC2D_TOP))
      allocate(store_val_norm_accel(NGLLSQUARE*NSPEC2D_TOP))

      allocate(store_val_x_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_y_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_z_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_ux_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_uy_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_uz_all(NGLLSQUARE*NSPEC2D_TOP,0:NPROC-1))
    else
      allocate(store_val_x(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_y(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_z(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_ux(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_uy(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_uz(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_norm_displ(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_norm_veloc(NGNOD2D_AVS_DX*NSPEC2D_TOP))
      allocate(store_val_norm_accel(NGNOD2D_AVS_DX*NSPEC2D_TOP))

      allocate(store_val_x_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_y_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_z_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_ux_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_uy_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
      allocate(store_val_uz_all(NGNOD2D_AVS_DX*NSPEC2D_TOP,0:NPROC-1))
    endif

! to compute max of norm for shaking map
    store_val_norm_displ(:) = -1.
    store_val_norm_veloc(:) = -1.
    store_val_norm_accel(:) = -1.
  endif

!
!   s t a r t   t i m e   i t e r a t i o n s
!

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) '           time step: ',sngl(DT),' s'
    write(IMAIN,*) 'number of time steps: ',NSTEP
    write(IMAIN,*) 'total simulated time: ',sngl(NSTEP*DT),' seconds'
    write(IMAIN,*)
  endif

! distinguish whether single or double precision for reals
  if(CUSTOM_REAL == SIZE_REAL) then
    deltat = sngl(DT)
  else
    deltat = DT
  endif
  deltatover2 = deltat/2.
  deltatsqover2 = deltat*deltat/2.

! precompute Runge-Kutta coefficients if attenuation
  if(ATTENUATION) then
    tauinv(:,:) = - 1. / tau_sigma(:,:)
    factor_common(:,:) = 2. * beta(:,:) * tauinv(:,:)
    alphaval(:,:) = 1 + deltat*tauinv(:,:) + deltat**2*tauinv(:,:)**2 / 2. + &
      deltat**3*tauinv(:,:)**3 / 6. + deltat**4*tauinv(:,:)**4 / 24.
    betaval(:,:) = deltat / 2. + deltat**2*tauinv(:,:) / 3. + deltat**3*tauinv(:,:)**2 / 8. + deltat**4*tauinv(:,:)**3 / 24.
    gammaval(:,:) = deltat / 2. + deltat**2*tauinv(:,:) / 6. + deltat**3*tauinv(:,:)**2 / 24.
  endif

  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'Starting time iteration loop...'
    write(IMAIN,*)
  endif

! create an empty file to monitor the start of the simulation
  if(myrank == 0) then
    open(unit=IOUT,file='OUTPUT_FILES/starttimeloop.txt',status='unknown')
    write(IOUT,*) 'starting time loop'
    close(IOUT)
  endif

! get MPI starting time
  time_start = MPI_WTIME()

! clear memory variables if attenuation
  if(ATTENUATION) then
    R_xx(:,:,:,:,:) = 0._CUSTOM_REAL
    R_yy(:,:,:,:,:) = 0._CUSTOM_REAL
    R_xy(:,:,:,:,:) = 0._CUSTOM_REAL
    R_xz(:,:,:,:,:) = 0._CUSTOM_REAL
    R_yz(:,:,:,:,:) = 0._CUSTOM_REAL

    if(FIX_UNDERFLOW_PROBLEM) then
      R_xx(:,:,:,:,:) = VERYSMALLVAL
      R_yy(:,:,:,:,:) = VERYSMALLVAL
      R_xy(:,:,:,:,:) = VERYSMALLVAL
      R_xz(:,:,:,:,:) = VERYSMALLVAL
      R_yz(:,:,:,:,:) = VERYSMALLVAL
    endif

  endif

! *********************************************************
! ************* MAIN LOOP OVER THE TIME STEPS *************
! *********************************************************

  do it=1,NSTEP

! compute the maximum of the norm of the displacement
! in all the slices using an MPI reduction
! and output timestamp file to check that simulation is running fine
  if(mod(it,ITAFF_TIME_STEPS) == 0 .or. it == 5) then

! compute maximum of norm of displacement in each slice
    Usolidnorm = maxval(sqrt(displ(1,:)**2 + displ(2,:)**2 + displ(3,:)**2))

! compute the maximum of the maxima for all the slices using an MPI reduction
    call MPI_REDUCE(Usolidnorm,Usolidnorm_all,1,CUSTOM_MPI_TYPE,MPI_MAX,0, &
                          MPI_COMM_WORLD,ier)

    if(myrank == 0) then

      write(IMAIN,*) 'Time step # ',it
      write(IMAIN,*) 'Time: ',sngl((it-1)*DT-hdur(1)),' seconds'

! elapsed time since beginning of the simulation
      tCPU = MPI_WTIME() - time_start
      int_tCPU = int(tCPU)
      ihours = int_tCPU / 3600
      iminutes = (int_tCPU - 3600*ihours) / 60
      iseconds = int_tCPU - 3600*ihours - 60*iminutes
      write(IMAIN,*) 'Elapsed time in seconds = ',tCPU
      write(IMAIN,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IMAIN,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IMAIN,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      write(IMAIN,*)

! write time stamp file to give information about progression of simulation
      write(outputname,"('OUTPUT_FILES/timestamp',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown')
      write(IOUT,*) 'Time step # ',it
      write(IOUT,*) 'Time: ',sngl((it-1)*DT-hdur(1)),' seconds'
      write(IOUT,*) 'Elapsed time in seconds = ',tCPU
      write(IOUT,"(' Elapsed time in hh:mm:ss = ',i4,' h ',i2.2,' m ',i2.2,' s')") ihours,iminutes,iseconds
      write(IOUT,*) 'Mean elapsed time per time step in seconds = ',tCPU/dble(it)
      write(IOUT,*) 'Max norm displacement vector U in solid in all slices (m) = ',Usolidnorm_all
      close(IOUT)

! check stability of the code, exit if unstable
      if(Usolidnorm_all > STABILITY_THRESHOLD) call exit_MPI(myrank,'code became unstable and blew up')

    endif
  endif

! update displacement using finite difference time scheme
 do i=1,NGLOB_AB
   displ(:,i) = displ(:,i) + deltat*veloc(:,i) + deltatsqover2*accel(:,i)
   veloc(:,i) = veloc(:,i) + deltatover2*accel(:,i)
   accel(:,i) = 0._CUSTOM_REAL
 enddo

  do ispec = 1,NSPEC_AB

    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0.
          tempx2l = 0.
          tempx3l = 0.

          tempy1l = 0.
          tempy2l = 0.
          tempy3l = 0.

          tempz1l = 0.
          tempz2l = 0.
          tempz3l = 0.

          do l=1,NGLLX
            hp1 = hprime_xx(l,i)
            iglob = ibool(l,j,k,ispec)
            tempx1l = tempx1l + displ(1,iglob)*hp1
            tempy1l = tempy1l + displ(2,iglob)*hp1
            tempz1l = tempz1l + displ(3,iglob)*hp1
          enddo

          do l=1,NGLLY
            hp2 = hprime_yy(l,j)
            iglob = ibool(i,l,k,ispec)
            tempx2l = tempx2l + displ(1,iglob)*hp2
            tempy2l = tempy2l + displ(2,iglob)*hp2
            tempz2l = tempz2l + displ(3,iglob)*hp2
          enddo

          do l=1,NGLLZ
            hp3 = hprime_zz(l,k)
            iglob = ibool(i,j,l,ispec)
            tempx3l = tempx3l + displ(1,iglob)*hp3
            tempy3l = tempy3l + displ(2,iglob)*hp3
            tempz3l = tempz3l + displ(3,iglob)*hp3
          enddo

!         get derivatives of ux, uy and uz with respect to x, y and z
          xixl = xix(i,j,k,ispec)
          xiyl = xiy(i,j,k,ispec)
          xizl = xiz(i,j,k,ispec)
          etaxl = etax(i,j,k,ispec)
          etayl = etay(i,j,k,ispec)
          etazl = etaz(i,j,k,ispec)
          gammaxl = gammax(i,j,k,ispec)
          gammayl = gammay(i,j,k,ispec)
          gammazl = gammaz(i,j,k,ispec)
          jacobianl = jacobian(i,j,k,ispec)

          duxdxl = xixl*tempx1l + etaxl*tempx2l + gammaxl*tempx3l
          duxdyl = xiyl*tempx1l + etayl*tempx2l + gammayl*tempx3l
          duxdzl = xizl*tempx1l + etazl*tempx2l + gammazl*tempx3l

          duydxl = xixl*tempy1l + etaxl*tempy2l + gammaxl*tempy3l
          duydyl = xiyl*tempy1l + etayl*tempy2l + gammayl*tempy3l
          duydzl = xizl*tempy1l + etazl*tempy2l + gammazl*tempy3l

          duzdxl = xixl*tempz1l + etaxl*tempz2l + gammaxl*tempz3l
          duzdyl = xiyl*tempz1l + etayl*tempz2l + gammayl*tempz3l
          duzdzl = xizl*tempz1l + etazl*tempz2l + gammazl*tempz3l

! precompute some sums to save CPU time
          duxdxl_plus_duydyl = duxdxl + duydyl
          duxdxl_plus_duzdzl = duxdxl + duzdzl
          duydyl_plus_duzdzl = duydyl + duzdzl
          duxdyl_plus_duydxl = duxdyl + duydxl
          duzdxl_plus_duxdzl = duzdxl + duxdzl
          duzdyl_plus_duydzl = duzdyl + duydzl

! precompute terms for attenuation if needed
  if(ATTENUATION_VAL .and. not_fully_in_bedrock(ispec)) then

! compute deviatoric strain
    epsilon_trace_over_3 = ONE_THIRD * (duxdxl + duydyl + duzdzl)
    epsilondev_xx_loc(i,j,k) = duxdxl - epsilon_trace_over_3
    epsilondev_yy_loc(i,j,k) = duydyl - epsilon_trace_over_3
    epsilondev_xy_loc(i,j,k) = 0.5 * duxdyl_plus_duydxl
    epsilondev_xz_loc(i,j,k) = 0.5 * duzdxl_plus_duxdzl
    epsilondev_yz_loc(i,j,k) = 0.5 * duzdyl_plus_duydzl

! distinguish attenuation factors
    if(flag_sediments(i,j,k,ispec)) then
      iselected = IATTENUATION_SEDIMENTS
    else
      iselected = IATTENUATION_BEDROCK
    endif

    one_minus_sum_beta_use = one_minus_sum_beta(iselected)
    minus_sum_beta =  one_minus_sum_beta_use - 1.

  endif

    kappal = kappastore(i,j,k,ispec)
    mul = mustore(i,j,k,ispec)

! use unrelaxed parameters if attenuation
    if(ATTENUATION_VAL .and. not_fully_in_bedrock(ispec)) mul = mul * one_minus_sum_beta_use

          lambdalplus2mul = kappal + FOUR_THIRDS * mul
          lambdal = lambdalplus2mul - 2.*mul

! compute stress sigma
          sigma_xx = lambdalplus2mul*duxdxl + lambdal*duydyl_plus_duzdzl
          sigma_yy = lambdalplus2mul*duydyl + lambdal*duxdxl_plus_duzdzl
          sigma_zz = lambdalplus2mul*duzdzl + lambdal*duxdxl_plus_duydyl

          sigma_xy = mul*duxdyl_plus_duydxl
          sigma_xz = mul*duzdxl_plus_duxdzl
          sigma_yz = mul*duzdyl_plus_duydzl

! subtract memory variables if attenuation
  if(ATTENUATION_VAL .and. not_fully_in_bedrock(ispec)) then
    do i_sls = 1,N_SLS
      R_xx_val = R_xx(i,j,k,ispec,i_sls)
      R_yy_val = R_yy(i,j,k,ispec,i_sls)
      sigma_xx = sigma_xx - R_xx_val
      sigma_yy = sigma_yy - R_yy_val
      sigma_zz = sigma_zz + R_xx_val + R_yy_val
      sigma_xy = sigma_xy - R_xy(i,j,k,ispec,i_sls)
      sigma_xz = sigma_xz - R_xz(i,j,k,ispec,i_sls)
      sigma_yz = sigma_yz - R_yz(i,j,k,ispec,i_sls)
    enddo
  endif

! form dot product with test vector, symmetric form
      tempx1(i,j,k) = jacobianl * (sigma_xx*xixl + sigma_xy*xiyl + sigma_xz*xizl)
      tempy1(i,j,k) = jacobianl * (sigma_xy*xixl + sigma_yy*xiyl + sigma_yz*xizl)
      tempz1(i,j,k) = jacobianl * (sigma_xz*xixl + sigma_yz*xiyl + sigma_zz*xizl)

      tempx2(i,j,k) = jacobianl * (sigma_xx*etaxl + sigma_xy*etayl + sigma_xz*etazl)
      tempy2(i,j,k) = jacobianl * (sigma_xy*etaxl + sigma_yy*etayl + sigma_yz*etazl)
      tempz2(i,j,k) = jacobianl * (sigma_xz*etaxl + sigma_yz*etayl + sigma_zz*etazl)

      tempx3(i,j,k) = jacobianl * (sigma_xx*gammaxl + sigma_xy*gammayl + sigma_xz*gammazl)
      tempy3(i,j,k) = jacobianl * (sigma_xy*gammaxl + sigma_yy*gammayl + sigma_yz*gammazl)
      tempz3(i,j,k) = jacobianl * (sigma_xz*gammaxl + sigma_yz*gammayl + sigma_zz*gammazl)

          enddo
        enddo
      enddo

    do k=1,NGLLZ
      do j=1,NGLLY
        do i=1,NGLLX

          tempx1l = 0.
          tempy1l = 0.
          tempz1l = 0.

          tempx2l = 0.
          tempy2l = 0.
          tempz2l = 0.

          tempx3l = 0.
          tempy3l = 0.
          tempz3l = 0.

          do l=1,NGLLX
            fac1 = hprimewgll_xx(i,l)
            tempx1l = tempx1l + tempx1(l,j,k)*fac1
            tempy1l = tempy1l + tempy1(l,j,k)*fac1
            tempz1l = tempz1l + tempz1(l,j,k)*fac1
          enddo

          do l=1,NGLLY
            fac2 = hprimewgll_yy(j,l)
            tempx2l = tempx2l + tempx2(i,l,k)*fac2
            tempy2l = tempy2l + tempy2(i,l,k)*fac2
            tempz2l = tempz2l + tempz2(i,l,k)*fac2
          enddo

          do l=1,NGLLZ
            fac3 = hprimewgll_zz(k,l)
            tempx3l = tempx3l + tempx3(i,j,l)*fac3
            tempy3l = tempy3l + tempy3(i,j,l)*fac3
            tempz3l = tempz3l + tempz3(i,j,l)*fac3
          enddo

          fac1 = wgllwgll_yz(j,k)
          fac2 = wgllwgll_xz(i,k)
          fac3 = wgllwgll_xy(i,j)

! sum contributions from each element to the global mesh and add gravity terms

  iglob = ibool(i,j,k,ispec)

  accel(1,iglob) = accel(1,iglob) - (fac1*tempx1l + fac2*tempx2l + fac3*tempx3l)
  accel(2,iglob) = accel(2,iglob) - (fac1*tempy1l + fac2*tempy2l + fac3*tempy3l)
  accel(3,iglob) = accel(3,iglob) - (fac1*tempz1l + fac2*tempz2l + fac3*tempz3l)

! update memory variables based upon the Runge-Kutta scheme

  if(ATTENUATION_VAL .and. not_fully_in_bedrock(ispec)) then

! use Runge-Kutta scheme to march in time
  do i_sls = 1,N_SLS

! get coefficients for that standard linear solid

  factor_loc = mustore(i,j,k,ispec) * factor_common(iselected,i_sls)
  alphaval_loc = alphaval(iselected,i_sls)
  betaval_loc = betaval(iselected,i_sls)
  gammaval_loc = gammaval(iselected,i_sls)

! term in xx
  Sn   = factor_loc * epsilondev_xx(i,j,k,ispec)
  Snp1   = factor_loc * epsilondev_xx_loc(i,j,k)
  R_xx(i,j,k,ispec,i_sls) = alphaval_loc * R_xx(i,j,k,ispec,i_sls) + betaval_loc * Sn + gammaval_loc * Snp1

! term in yy
  Sn   = factor_loc * epsilondev_yy(i,j,k,ispec)
  Snp1   = factor_loc * epsilondev_yy_loc(i,j,k)
  R_yy(i,j,k,ispec,i_sls) = alphaval_loc * R_yy(i,j,k,ispec,i_sls) + betaval_loc * Sn + gammaval_loc * Snp1

! term in zz not computed since zero trace

! term in xy
  Sn   = factor_loc * epsilondev_xy(i,j,k,ispec)
  Snp1   = factor_loc * epsilondev_xy_loc(i,j,k)
  R_xy(i,j,k,ispec,i_sls) = alphaval_loc * R_xy(i,j,k,ispec,i_sls) + betaval_loc * Sn + gammaval_loc * Snp1

! term in xz
  Sn   = factor_loc * epsilondev_xz(i,j,k,ispec)
  Snp1   = factor_loc * epsilondev_xz_loc(i,j,k)
  R_xz(i,j,k,ispec,i_sls) = alphaval_loc * R_xz(i,j,k,ispec,i_sls) + betaval_loc * Sn + gammaval_loc * Snp1

! term in yz
  Sn   = factor_loc * epsilondev_yz(i,j,k,ispec)
  Snp1   = factor_loc * epsilondev_yz_loc(i,j,k)
  R_yz(i,j,k,ispec,i_sls) = alphaval_loc * R_yz(i,j,k,ispec,i_sls) + betaval_loc * Sn + gammaval_loc * Snp1

    enddo   ! end of loop on memory variables

  endif  !  end attenuation

        enddo
      enddo
    enddo

! save deviatoric strain for Runge-Kutta scheme
  if(ATTENUATION_VAL .and. not_fully_in_bedrock(ispec)) then
    epsilondev_xx(:,:,:,ispec) = epsilondev_xx_loc(:,:,:)
    epsilondev_yy(:,:,:,ispec) = epsilondev_yy_loc(:,:,:)
    epsilondev_xy(:,:,:,ispec) = epsilondev_xy_loc(:,:,:)
    epsilondev_xz(:,:,:,ispec) = epsilondev_xz_loc(:,:,:)
    epsilondev_yz(:,:,:,ispec) = epsilondev_yz_loc(:,:,:)
  endif

  enddo   ! spectral element loop

! add Stacey conditions

  if(STACEY_ABS_CONDITIONS) then

!   xmin
    do ispec2D=1,nspec2D_xmin

      ispec=ibelm_xmin(ispec2D)

! exclude elements that are not on absorbing edges
    if(nkmin_xi(1,ispec2D) == 0 .or. njmin(1,ispec2D) == 0) cycle

      i=1
      do k=nkmin_xi(1,ispec2D),NGLLZ
        do j=njmin(1,ispec2D),njmax(1,ispec2D)
          iglob=ibool(i,j,k,ispec)

          vx=veloc(1,iglob)
          vy=veloc(2,iglob)
          vz=veloc(3,iglob)

          nx=normal_xmin(1,j,k,ispec2D)
          ny=normal_xmin(2,j,k,ispec2D)
          nz=normal_xmin(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp(i,j,k,ispec)*vn*nx+rho_vs(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp(i,j,k,ispec)*vn*ny+rho_vs(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp(i,j,k,ispec)*vn*nz+rho_vs(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmin(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel(1,iglob)=accel(1,iglob) - tx*weight
          accel(2,iglob)=accel(2,iglob) - ty*weight
          accel(3,iglob)=accel(3,iglob) - tz*weight

        enddo
      enddo
    enddo

!   xmax
    do ispec2D=1,nspec2D_xmax
      ispec=ibelm_xmax(ispec2D)

! exclude elements that are not on absorbing edges
    if(nkmin_xi(2,ispec2D) == 0 .or. njmin(2,ispec2D) == 0) cycle

      i=NGLLX
      do k=nkmin_xi(2,ispec2D),NGLLZ
        do j=njmin(2,ispec2D),njmax(2,ispec2D)
          iglob=ibool(i,j,k,ispec)

          vx=veloc(1,iglob)
          vy=veloc(2,iglob)
          vz=veloc(3,iglob)

          nx=normal_xmax(1,j,k,ispec2D)
          ny=normal_xmax(2,j,k,ispec2D)
          nz=normal_xmax(3,j,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp(i,j,k,ispec)*vn*nx+rho_vs(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp(i,j,k,ispec)*vn*ny+rho_vs(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp(i,j,k,ispec)*vn*nz+rho_vs(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_xmax(j,k,ispec2D)*wgllwgll_yz(j,k)

          accel(1,iglob)=accel(1,iglob) - tx*weight
          accel(2,iglob)=accel(2,iglob) - ty*weight
          accel(3,iglob)=accel(3,iglob) - tz*weight

        enddo
      enddo
    enddo

!   ymin
    do ispec2D=1,nspec2D_ymin

      ispec=ibelm_ymin(ispec2D)

! exclude elements that are not on absorbing edges
    if(nkmin_eta(1,ispec2D) == 0 .or. nimin(1,ispec2D) == 0) cycle

      j=1
      do k=nkmin_eta(1,ispec2D),NGLLZ
        do i=nimin(1,ispec2D),nimax(1,ispec2D)
          iglob=ibool(i,j,k,ispec)

          vx=veloc(1,iglob)
          vy=veloc(2,iglob)
          vz=veloc(3,iglob)

          nx=normal_ymin(1,i,k,ispec2D)
          ny=normal_ymin(2,i,k,ispec2D)
          nz=normal_ymin(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp(i,j,k,ispec)*vn*nx+rho_vs(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp(i,j,k,ispec)*vn*ny+rho_vs(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp(i,j,k,ispec)*vn*nz+rho_vs(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymin(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel(1,iglob)=accel(1,iglob) - tx*weight
          accel(2,iglob)=accel(2,iglob) - ty*weight
          accel(3,iglob)=accel(3,iglob) - tz*weight

        enddo
      enddo
    enddo

!   ymax
    do ispec2D=1,nspec2D_ymax

      ispec=ibelm_ymax(ispec2D)

! exclude elements that are not on absorbing edges
    if(nkmin_eta(2,ispec2D) == 0 .or. nimin(2,ispec2D) == 0) cycle

      j=NGLLY
      do k=nkmin_eta(2,ispec2D),NGLLZ
        do i=nimin(2,ispec2D),nimax(2,ispec2D)
          iglob=ibool(i,j,k,ispec)

          vx=veloc(1,iglob)
          vy=veloc(2,iglob)
          vz=veloc(3,iglob)

          nx=normal_ymax(1,i,k,ispec2D)
          ny=normal_ymax(2,i,k,ispec2D)
          nz=normal_ymax(3,i,k,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp(i,j,k,ispec)*vn*nx+rho_vs(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp(i,j,k,ispec)*vn*ny+rho_vs(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp(i,j,k,ispec)*vn*nz+rho_vs(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_ymax(i,k,ispec2D)*wgllwgll_xz(i,k)

          accel(1,iglob)=accel(1,iglob) - tx*weight
          accel(2,iglob)=accel(2,iglob) - ty*weight
          accel(3,iglob)=accel(3,iglob) - tz*weight

        enddo
      enddo
    enddo


!   bottom (zmin)
    do ispec2D=1,NSPEC2D_BOTTOM

      ispec=ibelm_bottom(ispec2D)

      k=1
      do j=1,NGLLY
        do i=1,NGLLX

          iglob=ibool(i,j,k,ispec)

          vx=veloc(1,iglob)
          vy=veloc(2,iglob)
          vz=veloc(3,iglob)

          nx=normal_bottom(1,i,j,ispec2D)
          ny=normal_bottom(2,i,j,ispec2D)
          nz=normal_bottom(3,i,j,ispec2D)

          vn=vx*nx+vy*ny+vz*nz

          tx=rho_vp(i,j,k,ispec)*vn*nx+rho_vs(i,j,k,ispec)*(vx-vn*nx)
          ty=rho_vp(i,j,k,ispec)*vn*ny+rho_vs(i,j,k,ispec)*(vy-vn*ny)
          tz=rho_vp(i,j,k,ispec)*vn*nz+rho_vs(i,j,k,ispec)*(vz-vn*nz)

          weight=jacobian2D_bottom(i,j,ispec2D)*wgllwgll_xy(i,j)

          accel(1,iglob)=accel(1,iglob) - tx*weight
          accel(2,iglob)=accel(2,iglob) - ty*weight
          accel(3,iglob)=accel(3,iglob) - tz*weight

        enddo
      enddo
    enddo

  endif  ! end of Stacey conditions

  do isource = 1,NSOURCES

!   add the source (only if this proc carries the source)
    if(myrank == islice_selected_source(isource)) then

      stf = comp_source_time_function(dble(it-1)*DT-hdur(isource)-t_cmt(isource),hdur(isource))

!     distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        stf_used = sngl(stf)
      else
        stf_used = stf
      endif

!     add source array
      do k=1,NGLLZ
        do j=1,NGLLY
          do i=1,NGLLX
            iglob = ibool(i,j,k,ispec_selected_source(isource))
            accel(:,iglob) = accel(:,iglob) + sourcearrays(isource,:,i,j,k)*stf_used
          enddo
        enddo
      enddo

    endif

  enddo

! assemble all the contributions between slices using MPI
  call assemble_MPI_vector(accel,iproc_xi,iproc_eta,addressing, &
            iboolleft_xi,iboolright_xi,iboolleft_eta,iboolright_eta, &
            buffer_send_faces,buffer_received_faces,npoin2D_xi,npoin2D_eta, &
            NPROC_XI,NPROC_ETA,NPOIN2DMAX_XMIN_XMAX,NPOIN2DMAX_YMIN_YMAX,NPOIN2DMAX_XY)

  do i=1,NGLOB_AB
    accel(1,i) = accel(1,i)*rmass(i)
    accel(2,i) = accel(2,i)*rmass(i)
    accel(3,i) = accel(3,i)*rmass(i)
  enddo

  if(OCEANS) then

!   initialize the updates
    updated_dof_ocean_load(:) = .false.

! for surface elements exactly at the top of the model (ocean bottom)
    do ispec2D = 1,NSPEC2D_TOP

      ispec = ibelm_top(ispec2D)

! only for DOFs exactly at the top of the model (ocean bottom)
      k = NGLLZ

      do j = 1,NGLLY
        do i = 1,NGLLX

! get global point number
          iglob = ibool(i,j,k,ispec)

! only update once
          if(.not. updated_dof_ocean_load(iglob)) then

! get normal
            nx = normal_top(1,i,j,ispec2D)
            ny = normal_top(2,i,j,ispec2D)
            nz = normal_top(3,i,j,ispec2D)

! make updated component of right-hand side
! we divide by rmass() which is 1 / M
! we use the total force which includes the Coriolis term above
            force_normal_comp = (accel(1,iglob)*nx + &
                 accel(2,iglob)*ny + accel(3,iglob)*nz) / rmass(iglob)

            additional_term = (rmass_ocean_load(iglob) - rmass(iglob)) * force_normal_comp

            accel(1,iglob) = accel(1,iglob) + additional_term * nx
            accel(2,iglob) = accel(2,iglob) + additional_term * ny
            accel(3,iglob) = accel(3,iglob) + additional_term * nz

!           done with this point
            updated_dof_ocean_load(iglob) = .true.

          endif

        enddo
      enddo
    enddo
  endif

  do i=1,NGLOB_AB
    veloc(:,i) = veloc(:,i) + deltatover2*accel(:,i)
  enddo

! write the seismograms with time shift

  do irec_local = 1,nrec_local

! get global number of that receiver
    irec = number_receiver_global(irec_local)

! perform the general interpolation using Lagrange polynomials
        uxd = ZERO
        uyd = ZERO
        uzd = ZERO

        do j = 1,NGLLY
          do i = 1,NGLLX

! receivers are always located at the surface in the crustal region of the mesh
            iglob = ibool(i,j,NGLLZ,ispec_selected_rec(irec))

            hlagrange = hxir_store(irec_local,i)*hetar_store(irec_local,j)

! save displacement
            uxd = uxd + dble(displ(1,iglob))*hlagrange
            uyd = uyd + dble(displ(2,iglob))*hlagrange
            uzd = uzd + dble(displ(3,iglob))*hlagrange

          enddo
        enddo

! store North, East and Vertical components

! distinguish whether single or double precision for reals
      if(CUSTOM_REAL == SIZE_REAL) then
        seismograms(:,irec_local,it) = sngl((nu(:,1,irec)*uxd + nu(:,2,irec)*uyd + nu(:,3,irec)*uzd))
      else
        seismograms(:,irec_local,it) = (nu(:,1,irec)*uxd + nu(:,2,irec)*uyd + nu(:,3,irec)*uzd)
      endif

  enddo

! write the current seismograms
  if(mod(it,NSEIS) == 0) &
      call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,nrec,nrec_local,it,DT,NSTEP,hdur,LOCAL_PATH)

! save movie frame
  if(SAVE_AVS_DX_MOVIE .and. mod(it,NMOVIE) == 0) then

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP
      ispec = ibelm_top(ispec2D)
      k = NGLLZ

! save all points for high resolution, or only four corners for low resolution
    if(USE_HIGHRES_FOR_MOVIES) then

! loop on all the points inside the element
      do j = 1,NGLLY
      do i = 1,NGLLX
      ipoin = ipoin + 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      if(SAVE_DISPLACEMENT) then
        store_val_ux(ipoin) = displ(1,iglob)
        store_val_uy(ipoin) = displ(2,iglob)
        store_val_uz(ipoin) = displ(3,iglob)
      else
        store_val_ux(ipoin) = veloc(1,iglob)
        store_val_uy(ipoin) = veloc(2,iglob)
        store_val_uz(ipoin) = veloc(3,iglob)
      endif
      enddo
      enddo

    else

! first corner
      ipoin = ipoin + 1
      i = 1
      j = 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      if(SAVE_DISPLACEMENT) then
        store_val_ux(ipoin) = displ(1,iglob)
        store_val_uy(ipoin) = displ(2,iglob)
        store_val_uz(ipoin) = displ(3,iglob)
      else
        store_val_ux(ipoin) = veloc(1,iglob)
        store_val_uy(ipoin) = veloc(2,iglob)
        store_val_uz(ipoin) = veloc(3,iglob)
      endif

! second corner
      ipoin = ipoin + 1
      i = NGLLX
      j = 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      if(SAVE_DISPLACEMENT) then
        store_val_ux(ipoin) = displ(1,iglob)
        store_val_uy(ipoin) = displ(2,iglob)
        store_val_uz(ipoin) = displ(3,iglob)
      else
        store_val_ux(ipoin) = veloc(1,iglob)
        store_val_uy(ipoin) = veloc(2,iglob)
        store_val_uz(ipoin) = veloc(3,iglob)
      endif

! third corner
      ipoin = ipoin + 1
      i = NGLLX
      j = NGLLY
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      if(SAVE_DISPLACEMENT) then
        store_val_ux(ipoin) = displ(1,iglob)
        store_val_uy(ipoin) = displ(2,iglob)
        store_val_uz(ipoin) = displ(3,iglob)
      else
        store_val_ux(ipoin) = veloc(1,iglob)
        store_val_uy(ipoin) = veloc(2,iglob)
        store_val_uz(ipoin) = veloc(3,iglob)
      endif

! fourth corner
      ipoin = ipoin + 1
      i = 1
      j = NGLLY
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      if(SAVE_DISPLACEMENT) then
        store_val_ux(ipoin) = displ(1,iglob)
        store_val_uy(ipoin) = displ(2,iglob)
        store_val_uz(ipoin) = displ(3,iglob)
      else
        store_val_ux(ipoin) = veloc(1,iglob)
        store_val_uy(ipoin) = veloc(2,iglob)
        store_val_uz(ipoin) = veloc(3,iglob)
      endif
    endif

    enddo

! gather info on master proc
    if(USE_HIGHRES_FOR_MOVIES) then
      ispec = NGLLSQUARE*NSPEC2D_TOP
    else
      ispec = NGNOD2D_AVS_DX*NSPEC2D_TOP
    endif

    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_ux,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uy,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_uz,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      write(outputname,"('OUTPUT_FILES/moviedata',i6.6)") it
      open(unit=IOUT,file=outputname,status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

  endif

! compute shaking intensity map
  if(SAVE_AVS_DX_MOVIE) then

! get coordinates of surface mesh and surface displacement
    ipoin = 0
    do ispec2D = 1,NSPEC2D_TOP
      ispec = ibelm_top(ispec2D)
      k = NGLLZ

! save all points for high resolution, or only four corners for low resolution
    if(USE_HIGHRES_FOR_MOVIES) then

! loop on all the points inside the element
      do j = 1,NGLLY
      do i = 1,NGLLX
      ipoin = ipoin + 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      store_val_norm_displ(ipoin) = max(store_val_norm_displ(ipoin),sqrt(displ(1,iglob)**2+displ(2,iglob)**2+displ(3,iglob)**2))
      store_val_norm_veloc(ipoin) = max(store_val_norm_veloc(ipoin),sqrt(veloc(1,iglob)**2+veloc(2,iglob)**2+veloc(3,iglob)**2))
      store_val_norm_accel(ipoin) = max(store_val_norm_accel(ipoin),sqrt(accel(1,iglob)**2+accel(2,iglob)**2+accel(3,iglob)**2))
      enddo
      enddo

    else

! first corner
      ipoin = ipoin + 1
      i = 1
      j = 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      store_val_norm_displ(ipoin) = max(store_val_norm_displ(ipoin),sqrt(displ(1,iglob)**2+displ(2,iglob)**2+displ(3,iglob)**2))
      store_val_norm_veloc(ipoin) = max(store_val_norm_veloc(ipoin),sqrt(veloc(1,iglob)**2+veloc(2,iglob)**2+veloc(3,iglob)**2))
      store_val_norm_accel(ipoin) = max(store_val_norm_accel(ipoin),sqrt(accel(1,iglob)**2+accel(2,iglob)**2+accel(3,iglob)**2))

! second corner
      ipoin = ipoin + 1
      i = NGLLX
      j = 1
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      store_val_norm_displ(ipoin) = max(store_val_norm_displ(ipoin),sqrt(displ(1,iglob)**2+displ(2,iglob)**2+displ(3,iglob)**2))
      store_val_norm_veloc(ipoin) = max(store_val_norm_veloc(ipoin),sqrt(veloc(1,iglob)**2+veloc(2,iglob)**2+veloc(3,iglob)**2))
      store_val_norm_accel(ipoin) = max(store_val_norm_accel(ipoin),sqrt(accel(1,iglob)**2+accel(2,iglob)**2+accel(3,iglob)**2))

! third corner
      ipoin = ipoin + 1
      i = NGLLX
      j = NGLLY
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      store_val_norm_displ(ipoin) = max(store_val_norm_displ(ipoin),sqrt(displ(1,iglob)**2+displ(2,iglob)**2+displ(3,iglob)**2))
      store_val_norm_veloc(ipoin) = max(store_val_norm_veloc(ipoin),sqrt(veloc(1,iglob)**2+veloc(2,iglob)**2+veloc(3,iglob)**2))
      store_val_norm_accel(ipoin) = max(store_val_norm_accel(ipoin),sqrt(accel(1,iglob)**2+accel(2,iglob)**2+accel(3,iglob)**2))

! fourth corner
      ipoin = ipoin + 1
      i = 1
      j = NGLLY
      iglob = ibool(i,j,k,ispec)
      store_val_x(ipoin) = xstore(iglob)
      store_val_y(ipoin) = ystore(iglob)
      store_val_z(ipoin) = zstore(iglob)
      store_val_norm_displ(ipoin) = max(store_val_norm_displ(ipoin),sqrt(displ(1,iglob)**2+displ(2,iglob)**2+displ(3,iglob)**2))
      store_val_norm_veloc(ipoin) = max(store_val_norm_veloc(ipoin),sqrt(veloc(1,iglob)**2+veloc(2,iglob)**2+veloc(3,iglob)**2))
      store_val_norm_accel(ipoin) = max(store_val_norm_accel(ipoin),sqrt(accel(1,iglob)**2+accel(2,iglob)**2+accel(3,iglob)**2))

    endif

    enddo

! save shakemap only at the end of the simulation
    if(it == NSTEP) then

! gather info on master proc
    if(USE_HIGHRES_FOR_MOVIES) then
      ispec = NGLLSQUARE*NSPEC2D_TOP
    else
      ispec = NGNOD2D_AVS_DX*NSPEC2D_TOP
    endif

    call MPI_GATHER(store_val_x,ispec,CUSTOM_MPI_TYPE,store_val_x_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_y,ispec,CUSTOM_MPI_TYPE,store_val_y_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_z,ispec,CUSTOM_MPI_TYPE,store_val_z_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_norm_displ,ispec,CUSTOM_MPI_TYPE,store_val_ux_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_norm_veloc,ispec,CUSTOM_MPI_TYPE,store_val_uy_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)
    call MPI_GATHER(store_val_norm_accel,ispec,CUSTOM_MPI_TYPE,store_val_uz_all,ispec,CUSTOM_MPI_TYPE,0,MPI_COMM_WORLD,ier)

! save movie data to disk in home directory
    if(myrank == 0) then
      open(unit=IOUT,file='OUTPUT_FILES/shakingdata',status='unknown',form='unformatted')
      write(IOUT) store_val_x_all
      write(IOUT) store_val_y_all
      write(IOUT) store_val_z_all
! this saves norm of displacement, velocity and acceleration
! but we use the same ux, uy, uz arrays as for the movies to save memory
      write(IOUT) store_val_ux_all
      write(IOUT) store_val_uy_all
      write(IOUT) store_val_uz_all
      close(IOUT)
    endif

    endif
  endif

!
!---- end of time iteration loop
!
  enddo   ! end of main time loop

! write the final seismograms
  call write_seismograms(myrank,seismograms,number_receiver_global,station_name, &
          network_name,nrec,nrec_local,it,DT,NSTEP,hdur(1),LOCAL_PATH)

! close the main output file
  if(myrank == 0) then
    write(IMAIN,*)
    write(IMAIN,*) 'End of the simulation'
    write(IMAIN,*)
    close(IMAIN)
  endif

! synchronize all the processes to make sure everybody has finished
  call MPI_BARRIER(MPI_COMM_WORLD,ier)

! stop all the MPI processes, and exit
  call MPI_FINALIZE(ier)

  end program specfem3D

